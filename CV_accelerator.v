
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module CV_accelerator(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output	    [12:0]		DRAM_ADDR,
	output	     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 	    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output	     [6:0]		HEX0,
	output	     [6:0]		HEX1,
	output	     [6:0]		HEX2,
	output	     [6:0]		HEX3,
	output	     [6:0]		HEX4,
	output	     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 	     [3:0]		KEY,

	//////////// LED //////////
	output	     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 	     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 	     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output	     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output	     [7:0]		VGA_G,
	output		          		VGA_HS,
	output	     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [16:0] vga_addr;
wire [7:0]  vga_data;
wire        clk_25;

wire        ram_wr_en;
wire [16:0] ram_wr_addr;
wire [7:0]  ram_wr_data;

wire        avl_write;
wire [16:0] avl_address;
wire [7:0]  avl_writedata;
wire        avl_read;
wire [7:0]  avl_readdata;
wire        avl_waitrequest;
wire        avl_mm_reset;

wire [16:0] fb_det_addr;
wire [7:0]  fb_det_data;

reg         det_frame_start;
wire        det_pixel_valid;
wire [7:0]  det_pixel;

wire        det_busy;
wire        det_valid;
wire [9:0]  det_x;
wire [8:0]  det_y;
wire [9:0]  det_w;
wire [8:0]  det_h;

reg  [9:0]  box_valid;
reg  [99:0] box_x;
reg  [89:0] box_y;
reg  [99:0] box_w;
reg  [89:0] box_h;
reg  [3:0]  box_count;

reg  signed [31:0] stage0_thr_adj;
reg  signed [31:0] stage1_thr_adj;
reg  signed [31:0] stage2_thr_adj;
reg  signed [31:0] stage3_thr_adj;

reg  key1_d;
reg  key2_d;
reg  key3_d;
wire key1_press = key1_d & ~KEY[1];
wire key2_press = key2_d & ~KEY[2];
wire key3_press = key3_d & ~KEY[3];

wire [1:0] stage_sel = SW[1:0];

function signed [31:0] step_val;
	input [1:0] sel;
	begin
		case (sel)
			2'b00: step_val = 32'sd1;
			2'b01: step_val = 32'sd2;
			2'b10: step_val = 32'sd4;
			default: step_val = 32'sd8;
		endcase
	end
endfunction

//=======================================================
//  Structural coding
//=======================================================

reg clk_div;
always @(posedge CLOCK_50) begin
    clk_div <= ~clk_div;
end
assign clk_25 = clk_div;

assign ram_wr_en = avl_write;
assign ram_wr_addr = avl_address;
assign ram_wr_data = avl_writedata;

assign avl_readdata = 8'b0;
assign avl_waitrequest = 1'b0;

avalon_jtag u_avalon_jtag (
	.clk_clk                           (CLOCK_50),
	.reset_reset_n                     (KEY[0]),
	.AVL_MM_slave_0_avs_s0_address     (avl_address),
	.AVL_MM_slave_0_avs_s0_read        (avl_read),
	.AVL_MM_slave_0_avs_s0_readdata    (avl_readdata),
	.AVL_MM_slave_0_avs_s0_write       (avl_write),
	.AVL_MM_slave_0_avs_s0_writedata   (avl_writedata),
	.AVL_MM_slave_0_avs_s0_waitrequest (avl_waitrequest),
	.AVL_MM_slave_0_reset_reset        (avl_mm_reset)
);

ram2port_320x240 u_ram (
    .clock_wr   ( CLOCK_50 ),
	.clock_rd   ( clk_25 ),
	.data       ( ram_wr_data ),
    .rdaddress  ( vga_addr ),
	.rdaddress_a( fb_det_addr ),
	.wraddress  ( ram_wr_addr ),
	.wren       ( ram_wr_en ),
	.q          ( vga_data ),
	.qa         ( fb_det_data )
);

vga_controller u_vga (
    .clk        (clk_25),
    .reset_n    (KEY[0]),
    .vram_data  (vga_data),
	.box_valid  (box_valid),
	.box_x      (box_x),
	.box_y      (box_y),
	.box_w      (box_w),
	.box_h      (box_h),
    .vram_addr  (vga_addr),
    .hsync      (VGA_HS),
    .vsync      (VGA_VS),
    .vga_r      (VGA_R),
    .vga_g      (VGA_G),
    .vga_b      (VGA_B),
    .vga_blank_n(VGA_BLANK_N),
    .vga_sync_n (VGA_SYNC_N),
    .vga_clk    (VGA_CLK)
);



localparam integer FB_SIZE = 76800; // 320*240
localparam integer INIT_DELAY_CYCLES = 600;

reg started;
reg [9:0] init_delay_cnt;
reg issue_en;
reg issue_en_d1;
reg issue_en_d2;
reg [16:0] addr_issue;
reg face_seen;

assign fb_det_addr = addr_issue;

always @(posedge clk_25 or negedge KEY[0]) begin
	if (!KEY[0]) begin
		started <= 1'b0;
		det_frame_start <= 1'b0;

		init_delay_cnt <= 10'd0;
		issue_en <= 1'b0;
		issue_en_d1 <= 1'b0;
		issue_en_d2 <= 1'b0;
		addr_issue <= 17'd0;
		face_seen <= 1'b0;
		box_valid <= 10'd0;
		box_x <= 100'd0;
		box_y <= 90'd0;
		box_w <= 100'd0;
		box_h <= 90'd0;
		box_count <= 4'd0;

		stage0_thr_adj <= 32'sd0;
		stage1_thr_adj <= 32'sd0;
		stage2_thr_adj <= 32'sd0;
		stage3_thr_adj <= 32'sd0;

		key1_d <= 1'b1;
		key2_d <= 1'b1;
		key3_d <= 1'b1;
	end else begin
		det_frame_start <= 1'b0;

		key1_d <= KEY[1];
		key2_d <= KEY[2];
		key3_d <= KEY[3];

		if (key1_press) begin
			case (stage_sel)
				2'd0: stage0_thr_adj <= stage0_thr_adj + step_val(SW[3:2]);
				2'd1: stage1_thr_adj <= stage1_thr_adj + step_val(SW[3:2]);
				2'd2: stage2_thr_adj <= stage2_thr_adj + step_val(SW[3:2]);
				default: stage3_thr_adj <= stage3_thr_adj + step_val(SW[3:2]);
			endcase
		end
		if (key2_press) begin
			case (stage_sel)
				2'd0: stage0_thr_adj <= stage0_thr_adj - step_val(SW[3:2]);
				2'd1: stage1_thr_adj <= stage1_thr_adj - step_val(SW[3:2]);
				2'd2: stage2_thr_adj <= stage2_thr_adj - step_val(SW[3:2]);
				default: stage3_thr_adj <= stage3_thr_adj - step_val(SW[3:2]);
			endcase
		end

		if (key3_press) begin
			started <= 1'b0;
			det_frame_start <= 1'b1;
			init_delay_cnt <= 10'd0;
			issue_en <= 1'b0;
			issue_en_d1 <= 1'b0;
			issue_en_d2 <= 1'b0;
			addr_issue <= 17'd0;
			face_seen <= 1'b0;
			box_valid <= 10'd0;
			box_x <= 100'd0;
			box_y <= 90'd0;
			box_w <= 100'd0;
			box_h <= 90'd0;
			box_count <= 4'd0;
		end else begin

		if (!started) begin
			started <= 1'b1;
			det_frame_start <= 1'b1;
			init_delay_cnt <= 10'd0;
			addr_issue <= 17'd0;
			issue_en <= 1'b0;
			issue_en_d1 <= 1'b0;
			issue_en_d2 <= 1'b0;
			face_seen <= 1'b0;
			box_valid <= 10'd0;
			box_x <= 100'd0;
			box_y <= 90'd0;
			box_w <= 100'd0;
			box_h <= 90'd0;
			box_count <= 4'd0;
		end else begin
			if (!issue_en && (init_delay_cnt != INIT_DELAY_CYCLES[9:0])) begin
				init_delay_cnt <= init_delay_cnt + 10'd1;
				if (init_delay_cnt == (INIT_DELAY_CYCLES - 1)) begin
					issue_en <= 1'b1;
				end
			end

			if (issue_en) begin
				if (addr_issue == (FB_SIZE - 1)) begin
					issue_en <= 1'b0;
				end else begin
					addr_issue <= addr_issue + 17'd1;
				end
			end
		end
		end

		issue_en_d1 <= issue_en;
		issue_en_d2 <= issue_en_d1;

		if (det_valid) begin
			face_seen <= 1'b1;
			if (box_count < 4'd10) begin
				box_valid[box_count] <= 1'b1;
				box_x[box_count*10 +: 10] <= det_x;
				box_y[box_count*9 +: 9] <= det_y;
				box_w[box_count*10 +: 10] <= det_w;
				box_h[box_count*9 +: 9] <= det_h;
				box_count <= box_count + 4'd1;
			end
		end
	end
end

assign det_pixel_valid = issue_en_d2;
assign det_pixel = fb_det_data;

vj_detector_19x19 #(
	.IMG_W(320),
	.IMG_H(240),
	.II_W(321),
	.II_H(241),
	.ADDR_W(17),
	.II_DATA_W(25),
	.ST0_WEAK(2),
	.ST1_WEAK(5),
	.ST2_WEAK(10),
	.ST3_WEAK(15)
) u_vj (
	.clk(clk_25),
	.reset_n(KEY[0]),
	.frame_start(det_frame_start),
	.pixel_valid(det_pixel_valid),
	.pixel(det_pixel),
	.stage0_threshold_adj(stage0_thr_adj),
	.stage1_threshold_adj(stage1_thr_adj),
	.stage2_threshold_adj(stage2_thr_adj),
	.stage3_threshold_adj(stage3_thr_adj),
	.det_valid(det_valid),
	.det_x(det_x),
	.det_y(det_y),
	.det_w(det_w),
	.det_h(det_h),
	.busy(det_busy)
);

assign LEDR[0] = det_busy;
assign LEDR[1] = face_seen;
assign LEDR[9:2] = 8'b0;



endmodule
