
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module CV_accelerator(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [16:0] vga_addr;
wire [7:0]  vga_data;
wire        clk_25;

wire [16:0] fb_det_addr;
wire [7:0]  fb_det_data;

reg         det_frame_start;
wire        det_pixel_valid;
wire [7:0]  det_pixel;

wire        det_busy;
wire        det_valid;
wire [9:0]  det_x;
wire [8:0]  det_y;
wire [9:0]  det_w;
wire [8:0]  det_h;

reg  [9:0]  box_valid;
reg  [99:0] box_x;
reg  [89:0] box_y;
reg  [99:0] box_w;
reg  [89:0] box_h;
reg  [3:0]  box_count;

//=======================================================
//  Structural coding
//=======================================================

reg clk_div;
always @(posedge CLOCK_50) begin
    clk_div <= ~clk_div;
end
assign clk_25 = clk_div;

ram2port_320x240 u_ram (
    .clock      ( clk_25 ),
    .data       ( 8'b0 ),
    .rdaddress  ( vga_addr ),
	.rdaddress_a( fb_det_addr ),
    .wraddress  ( 17'd0 ),
    .wren       ( 1'b0 ),
	.q          ( vga_data ),
	.qa         ( fb_det_data )
);

vga_controller u_vga (
    .clk        (clk_25),
    .reset_n    (KEY[0]),
    .vram_data  (vga_data),
	.box_valid  (box_valid),
	.box_x      (box_x),
	.box_y      (box_y),
	.box_w      (box_w),
	.box_h      (box_h),
    .vram_addr  (vga_addr),
    .hsync      (VGA_HS),
    .vsync      (VGA_VS),
    .vga_r      (VGA_R),
    .vga_g      (VGA_G),
    .vga_b      (VGA_B),
    .vga_blank_n(VGA_BLANK_N),
    .vga_sync_n (VGA_SYNC_N),
    .vga_clk    (VGA_CLK)
);



localparam integer FB_SIZE = 76800; // 320*240
localparam integer INIT_DELAY_CYCLES = 600;

reg started;
reg [9:0] init_delay_cnt;
reg issue_en;
reg issue_en_d1;
reg issue_en_d2;
reg [16:0] addr_issue;
reg face_seen;

assign fb_det_addr = addr_issue;

always @(posedge clk_25 or negedge KEY[0]) begin
	if (!KEY[0]) begin
		started <= 1'b0;
		det_frame_start <= 1'b0;

		init_delay_cnt <= 10'd0;
		issue_en <= 1'b0;
		issue_en_d1 <= 1'b0;
		issue_en_d2 <= 1'b0;
		addr_issue <= 17'd0;
		face_seen <= 1'b0;
		box_valid <= 10'd0;
		box_x <= 100'd0;
		box_y <= 90'd0;
		box_w <= 100'd0;
		box_h <= 90'd0;
		box_count <= 4'd0;
	end else begin
		det_frame_start <= 1'b0;

		if (!started) begin
			started <= 1'b1;
			det_frame_start <= 1'b1;
			init_delay_cnt <= 10'd0;
			addr_issue <= 17'd0;
			issue_en <= 1'b0;
			issue_en_d1 <= 1'b0;
			issue_en_d2 <= 1'b0;
			face_seen <= 1'b0;
			box_valid <= 10'd0;
			box_x <= 100'd0;
			box_y <= 90'd0;
			box_w <= 100'd0;
			box_h <= 90'd0;
			box_count <= 4'd0;
		end else begin
			if (!issue_en && (init_delay_cnt != INIT_DELAY_CYCLES[9:0])) begin
				init_delay_cnt <= init_delay_cnt + 10'd1;
				if (init_delay_cnt == (INIT_DELAY_CYCLES - 1)) begin
					issue_en <= 1'b1;
				end
			end

			if (issue_en) begin
				if (addr_issue == (FB_SIZE - 1)) begin
					issue_en <= 1'b0;
				end else begin
					addr_issue <= addr_issue + 17'd1;
				end
			end
		end

		issue_en_d1 <= issue_en;
		issue_en_d2 <= issue_en_d1;

		if (det_valid) begin
			face_seen <= 1'b1;
			if (box_count < 4'd10) begin
				box_valid[box_count] <= 1'b1;
				box_x[box_count*10 +: 10] <= det_x;
				box_y[box_count*9 +: 9] <= det_y;
				box_w[box_count*10 +: 10] <= det_w;
				box_h[box_count*9 +: 9] <= det_h;
				box_count <= box_count + 4'd1;
			end
		end
	end
end

assign det_pixel_valid = issue_en_d2;
assign det_pixel = fb_det_data;

vj_detector_19x19 #(
	.IMG_W(320),
	.IMG_H(240),
	.II_W(321),
	.II_H(241),
	.ADDR_W(17),
	.II_DATA_W(25),
	.ST0_WEAK(1),
	.ST1_WEAK(5),
	.ST2_WEAK(10)
) u_vj (
	.clk(clk_25),
	.reset_n(KEY[0]),
	.frame_start(det_frame_start),
	.pixel_valid(det_pixel_valid),
	.pixel(det_pixel),
	.det_valid(det_valid),
	.det_x(det_x),
	.det_y(det_y),
	.det_w(det_w),
	.det_h(det_h),
	.busy(det_busy)
);

assign LEDR[0] = det_busy;
assign LEDR[1] = face_seen;
assign LEDR[9:2] = 8'b0;



endmodule
